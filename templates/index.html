<!DOCTYPE html>
<html>
<head>
    <title>OFC Pineapple AI</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        /* Стили оставляем как в вашем примере, они хорошие */
        body { margin: 0; padding: 20px; font-family: Arial, sans-serif; background-color: #f0f0f0; overflow-x: hidden; min-height: 100vh; padding-bottom: 150px; box-sizing: border-box; }
        .controls { display: flex; justify-content: center; gap: 10px; margin-bottom: 20px; position: sticky; top: 0; z-index: 1001; background: #f0f0f0; padding: 10px; }
        button { padding: 12px 24px; font-size: 16px; border: none; border-radius: 5px; cursor: pointer; background-color: #4CAF50; color: white; transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        button:hover { background-color: #45a049; transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        button:active { transform: translateY(1px); box-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        .fullscreen-btn { position: fixed; top: 10px; right: 10px; background: none; border: none; color: #333; cursor: pointer; z-index: 1002; padding: 8px; box-shadow: none; }
        .table { display: grid; grid-template-rows: auto auto auto; gap: 10px; margin: 15px auto; width: 95%; max-width: 800px; background-color: #1a472a; padding: 15px; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); box-sizing: border-box; }
        .row { display: flex; justify-content: center; gap: 1.5%; min-height: 90px; padding: 5px; border-radius: 5px; background-color: rgba(255,255,255,0.1); flex-wrap: nowrap; }
        .card { width: 60px; height: 85px; border-radius: 6px; background-color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; cursor: pointer; font-size: 18px; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.2); position: relative; flex-shrink: 0; transition: transform 0.2s, box-shadow 0.2s, border 0.2s; user-select: none; -webkit-user-select: none; touch-action: none; box-sizing: border-box; border: 2px solid transparent; }
        .card[data-suit="♥"], .card[data-suit="♦"] { color: #e44145; }
        .card[data-suit="♣"], .card[data-suit="♠"] { color: #2d2d2d; }
        .card-slot { width: 60px; height: 85px; border: 2px dashed rgba(255,255,255,0.3); border-radius: 6px; flex-shrink: 0; transition: all 0.3s ease; display: flex; justify-content: center; align-items: center; }
        .card-slot.drag-over { background-color: rgba(255,255,255,0.2); border-color: white; transform: scale(1.05); }
        #hand-area { position: fixed; bottom: 0; left: 0; right: 0; background: #e0e0e0; padding: 15px; display: flex; justify-content: center; gap: 10px; z-index: 1000; flex-wrap: wrap; box-shadow: 0 -2px 10px rgba(0,0,0,0.1); min-height: 110px; align-items: center;}
        .dragging { opacity: 0.5; transform: scale(1.05); }
        .selected { border: 2px solid #007bff; transform: scale(1.05); }
        .discard-pile { margin-top: 10px; text-align: center; color: #555; font-size: 14px; }
        .message-area { text-align: center; margin-bottom: 15px; font-weight: bold; color: #333; min-height: 20px;}
        .player-label { text-align: center; color: white; font-weight: bold; margin-bottom: 5px; }

        /* Стили для анимации подсчета очков - TODO */
        .score-animation { /* ... */ }

        @media (max-width: 600px) {
            .card, .card-slot { width: 45px; height: 65px; font-size: 14px; border-radius: 4px;}
            .row { min-height: 70px; }
            #hand-area { padding: 10px; min-height: 90px; }
            body { padding: 5px; padding-bottom: 100px; }
        }
    </style>
</head>
<body>
    <button class="fullscreen-btn" onclick="toggleFullScreen()">
        <span class="material-icons">fullscreen</span>
    </button>

    <div class="controls">
        <button id="start-button" onclick="startGame()">Начать Раунд</button>
        <button id="confirm-button" onclick="confirmMove()" disabled>Подтвердить Ход</button>
        <!-- <button onclick="window.location.href='/training'">Тренировка</button> -->
    </div>

    <div class="message-area" id="message-area">Нажмите "Начать Раунд"</div>

    <div class="player-label">AI Player</div>
    <div class="table" id="ai-table">
        <div class="row top" id="ai-top-row"></div>
        <div class="row middle" id="ai-middle-row"></div>
        <div class="row bottom" id="ai-bottom-row"></div>
    </div>

    <div class="player-label">Human Player</div>
    <div class="table" id="player-table">
        <div class="row top" id="player-top-row"></div>
        <div class="row middle" id="player-middle-row"></div>
        <div class="row bottom" id="player-bottom-row"></div>
    </div>

    <div id="hand-area">
        <div id="hand"></div>
        <div id="discard-selection" style="margin-left: 20px;">
             <button id="discard-button" onclick="selectCardToDiscard()" disabled>Сбросить</button>
             <span id="discard-info"></span>
        </div>
    </div>
    <div class="discard-pile" id="discard-pile">Сброс: -</div>

<script>
    let currentGameState = null; // Будет хранить состояние от сервера
    let humanPlayerIndex = 0; // Индекс человека (обычно 0)
    let selectedCardsForPlacement = []; // Карты, выбранные для размещения
    let selectedCardToDiscard = null; // Карта, выбранная для сброса
    let placedCardsThisTurn = []; // { card: Card, row: string, index: int }

    const confirmButton = document.getElementById('confirm-button');
    const discardButton = document.getElementById('discard-button');
    const discardInfo = document.getElementById('discard-info');
    const messageArea = document.getElementById('message-area');
    const handElement = document.getElementById('hand');

    function toggleFullScreen() {
        if (!document.fullscreenElement) { document.documentElement.requestFullscreen(); }
        else { if (document.exitFullscreen) { document.exitFullscreen(); } }
    }

    function createCardElement(cardStr, isInteractive = true) {
        if (!cardStr || cardStr === "__") return null;
        const cardElement = document.createElement('div');
        cardElement.className = 'card';
        const rank = cardStr.length === 3 ? cardStr.substring(0, 2) : cardStr.substring(0, 1); // Для 10
        const suitChar = cardStr.substring(cardStr.length - 1);
        const suitSymbolMap = {'c': '♣', 'd': '♦', 'h': '♥', 's': '♠'};
        const suit = suitSymbolMap[suitChar] || suitChar;

        cardElement.dataset.card = cardStr; // Сохраняем строку карты
        cardElement.dataset.rank = rank;
        cardElement.dataset.suit = suit;
        cardElement.innerHTML = `<span>${rank}</span><span>${suit}</span>`; // Отображаем ранг и символ масти

        if (cardStr.includes('h') || cardStr.includes('d')) { cardElement.style.color = '#e44145'; }
        else { cardElement.style.color = '#2d2d2d'; }

        if (isInteractive) {
            cardElement.onclick = () => handleCardClick(cardElement);
        } else {
            cardElement.style.cursor = 'default';
        }
        return cardElement;
    }

    function createCardSlotElement(row, index) {
        const slot = document.createElement('div');
        slot.className = 'card-slot';
        slot.dataset.row = row;
        slot.dataset.index = index;
        slot.onclick = () => handleSlotClick(slot);
        return slot;
    }

    function renderBoard(playerPrefix, boardData) {
        const topRow = document.getElementById(`${playerPrefix}-top-row`);
        const middleRow = document.getElementById(`${playerPrefix}-middle-row`);
        const bottomRow = document.getElementById(`${playerPrefix}-bottom-row`);
        topRow.innerHTML = ''; middleRow.innerHTML = ''; bottomRow.innerHTML = '';

        boardData.top.forEach((cardStr, index) => {
            const slot = createCardSlotElement('top', index);
            const cardEl = createCardElement(cardStr, false); // Карты на доске не интерактивны
            if (cardEl) slot.appendChild(cardEl);
            topRow.appendChild(slot);
        });
        boardData.middle.forEach((cardStr, index) => {
            const slot = createCardSlotElement('middle', index);
            const cardEl = createCardElement(cardStr, false);
            if (cardEl) slot.appendChild(cardEl);
            middleRow.appendChild(slot);
        });
        boardData.bottom.forEach((cardStr, index) => {
            const slot = createCardSlotElement('bottom', index);
            const cardEl = createCardElement(cardStr, false);
            if (cardEl) slot.appendChild(cardEl);
            bottomRow.appendChild(slot);
        });
    }

    function renderHand(handCards) {
        handElement.innerHTML = '';
        if (handCards && handCards.length > 0) {
            handCards.forEach(cardStr => {
                const cardEl = createCardElement(cardStr, true); // Карты в руке интерактивны
                if (cardEl) handElement.appendChild(cardEl);
            });
        }
        // Сбрасываем выбор при новой раздаче
        selectedCardsForPlacement = [];
        selectedCardToDiscard = null;
        placedCardsThisTurn = [];
        updateSelectionUI();
    }
    
    function renderDiscardPile(discardPileData) {
         const discardEl = document.getElementById('discard-pile');
         discardEl.textContent = "Сброс: " + (discardPileData.length > 0 ? discardPileData.join(', ') : '-');
    }

    function updateUI(stateData) {
        console.log("Updating UI with state:", stateData);
        currentGameState = stateData; // Сохраняем текущее состояние
        humanPlayerIndex = stateData.humanPlayerIndex;

        renderBoard('player', stateData.playerBoard);
        renderBoard('ai', stateData.opponentBoard);
        renderHand(stateData.hand); // Отображаем 3 или 5 карт
        renderDiscardPile(stateData.discardPile);
        messageArea.textContent = stateData.message || `Player ${stateData.currentPlayer}'s turn`;

        // Управляем кнопками
        const isHumanTurn = stateData.currentPlayer === humanPlayerIndex;
        const isFLPlacement = stateData.isFantasylandRound && stateData.playerFantasylandStatus;
        
        confirmButton.disabled = !isHumanTurn || stateData.isGameOver;
        discardButton.disabled = !isHumanTurn || stateData.isGameOver || stateData.street === 1 || isFLPlacement;
        
        // Если это ход человека и ФЛ, показываем руку ФЛ и меняем текст кнопки
        if (isHumanTurn && isFLPlacement) {
             renderHand(stateData.fantasylandHand); // Показываем 14-17 карт
             confirmButton.textContent = "Разместить Фантазию";
             discardButton.disabled = false; // Разрешаем выбор сброса для ФЛ
             discardInfo.textContent = `(Нужно сбросить ${stateData.fantasylandHand.length - 13})`;
        } else if (isHumanTurn && stateData.street > 1) {
             confirmButton.textContent = "Подтвердить Ход";
             discardButton.disabled = false; // Разрешаем выбор сброса для 2-5 улиц
             discardInfo.textContent = "(Нужно сбросить 1)";
        } else {
             confirmButton.textContent = "Подтвердить Ход";
             discardInfo.textContent = "";
        }
        
        document.getElementById('start-button').disabled = !stateData.isGameOver;
    }

    async function startGame() {
        messageArea.textContent = "Начинаем новый раунд...";
        confirmButton.disabled = true;
        discardButton.disabled = true;
        try {
            const response = await fetch('/start', { method: 'POST' });
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            updateUI(data);
        } catch (error) {
            console.error('Error starting game:', error);
            messageArea.textContent = "Ошибка начала игры.";
        }
    }

    function handleCardClick(cardElement) {
        if (currentGameState.currentPlayer !== humanPlayerIndex || currentGameState.isGameOver) return;

        const cardStr = cardElement.dataset.card;
        const isSelectedForPlacement = selectedCardsForPlacement.some(c => c.dataset.card === cardStr);
        const isSelectedForDiscard = selectedCardToDiscard && selectedCardToDiscard.dataset.card === cardStr;
        const maxPlacement = (currentGameState.street === 1 || (currentGameState.isFantasylandRound && currentGameState.playerFantasylandStatus)) ? 
                             (currentGameState.isFantasylandRound ? 13 : 5) : 2;
        const maxDiscard = (currentGameState.isFantasylandRound && currentGameState.playerFantasylandStatus) ? 
                           (currentGameState.fantasylandHand.length - 13) : (currentGameState.street > 1 ? 1 : 0);


        if (isSelectedForDiscard) {
            // Отменить выбор для сброса
            selectedCardToDiscard = null;
            cardElement.classList.remove('selected');
        } else if (isSelectedForPlacement) {
            // Отменить выбор для размещения
            selectedCardsForPlacement = selectedCardsForPlacement.filter(c => c.dataset.card !== cardStr);
            cardElement.classList.remove('selected');
        } else {
            // Выбрать для размещения или сброса
            if (discardModeActive && maxDiscard > 0 && !selectedCardToDiscard) { // Выбираем для сброса (только одну карту)
                 selectedCardToDiscard = cardElement;
                 cardElement.classList.add('selected');
                 discardModeActive = false; // Выходим из режима выбора сброса
                 discardButton.textContent = "Сбросить";
            } else if (selectedCardsForPlacement.length < maxPlacement && !selectedCardToDiscard) { // Выбираем для размещения
                 selectedCardsForPlacement.push(cardElement);
                 cardElement.classList.add('selected');
            } else {
                 console.log("Cannot select more cards for placement or discard already selected.");
            }
        }
        updateSelectionUI();
    }

    let discardModeActive = false;
    function selectCardToDiscard() {
         if (currentGameState.street > 1 || (currentGameState.isFantasylandRound && currentGameState.playerFantasylandStatus)) {
              discardModeActive = !discardModeActive;
              if (discardModeActive) {
                   messageArea.textContent = "Выберите карту для сброса.";
                   discardButton.textContent = "Отмена Сброса";
                   // Снимаем выделение с карт для размещения
                   selectedCardsForPlacement.forEach(c => c.classList.remove('selected'));
                   selectedCardsForPlacement = [];
              } else {
                   messageArea.textContent = `Player ${currentGameState.currentPlayer}'s turn.`;
                   discardButton.textContent = "Сбросить";
                   // Снимаем выделение с карты для сброса, если была выбрана
                   if(selectedCardToDiscard) selectedCardToDiscard.classList.remove('selected');
                   selectedCardToDiscard = null;
              }
         }
    }


    function handleSlotClick(slotElement) {
        if (currentGameState.currentPlayer !== humanPlayerIndex || currentGameState.isGameOver) return;
        if (selectedCardsForPlacement.length === 0) {
             console.log("No card selected for placement.");
             return;
         }
         // Не позволяем кликать на слоты AI
         if (slotElement.closest('#ai-table')) return;

        const row = slotElement.dataset.row;
        const index = parseInt(slotElement.dataset.index);

        // Проверяем, свободен ли слот
        if (slotElement.children.length > 0) {
            console.log("Slot is already occupied.");
            return;
        }
        
        // Проверяем, не размещали ли уже в этот слот в этом ходу
        if (placedCardsThisTurn.some(p => p.row === row && p.index === index)) {
             console.log("Slot already used this turn.");
             return;
        }

        // Берем последнюю выбранную карту
        const cardElement = selectedCardsForPlacement.pop();
        if (!cardElement) return;

        cardElement.classList.remove('selected');
        slotElement.appendChild(cardElement); // Перемещаем карту в слот
        cardElement.onclick = null; // Делаем карту на доске некликабельной
        cardElement.style.cursor = 'default';

        // Сохраняем информацию о размещении
        placedCardsThisTurn.push({
            card: card_from_str(cardElement.dataset.card), // Сохраняем объект карты
            row: row,
            index: index
        });

        updateSelectionUI();
    }

    function updateSelectionUI() {
        // Обновляем состояние кнопки подтверждения и информации о сбросе
        const maxPlacement = (currentGameState?.street === 1 || (currentGameState?.isFantasylandRound && currentGameState?.playerFantasylandStatus)) ?
                             (currentGameState.isFantasylandRound ? 13 : 5) : 2;
        const maxDiscard = (currentGameState?.isFantasylandRound && currentGameState?.playerFantasylandStatus) ?
                           (currentGameState.fantasylandHand?.length - 13) : (currentGameState?.street > 1 ? 1 : 0);

        const canConfirm = placedCardsThisTurn.length === maxPlacement &&
                           (maxDiscard === 0 || selectedCardToDiscard !== null);

        confirmButton.disabled = !canConfirm || currentGameState?.currentPlayer !== humanPlayerIndex || currentGameState?.isGameOver;

        if (maxDiscard > 0) {
             discardInfo.textContent = selectedCardToDiscard
                 ? `(Сброс: ${card_to_str(selectedCardToDiscard.dataset.card)})`
                 : `(Выберите ${maxDiscard} для сброса)`;
        } else {
             discardInfo.textContent = "";
        }
    }

    async function confirmMove() {
        if (confirmButton.disabled) return;

        messageArea.textContent = "Обработка хода...";
        confirmButton.disabled = true;
        discardButton.disabled = true;

        try {
            let endpoint = '/move';
            let payload = {};

            if (currentGameState.isFantasylandRound && currentGameState.playerFantasylandStatus) {
                endpoint = '/fantasyland_placement';
                // Собираем размещение из placedCardsThisTurn
                let placement = {'top': [], 'middle': [], 'bottom': []};
                placedCardsThisTurn.forEach(p => {
                    // Сортируем карты при добавлении для консистентности (хотя порядок важен для индексов)
                    # В placement нужно передавать строки карт
                    placement[p.row].push(card_to_str(p.card)); 
                });
                 # Сортировка внутри рядов не нужна, т.к. индексы важны
                 # for row in placement: placement[row].sort(key=lambda s: Card(s).int_rank)
                
                payload = {
                    placement: placement,
                    discarded: [card_to_str(selectedCardToDiscard.dataset.card)] # Для ФЛ может быть > 1, но пока 1
                };
            } else if (currentGameState.street === 1) {
                 payload = {
                     placements: placedCardsThisTurn.map(p => ({
                         card: card_to_str(p.card),
                         row: p.row,
                         index: p.index
                     }))
                 };
            } else { // Улицы 2-5
                 payload = {
                     placements: placedCardsThisTurn.map(p => ({
                         card: card_to_str(p.card),
                         row: p.row,
                         index: p.index
                     })),
                     discard: card_to_str(selectedCardToDiscard.dataset.card)
                 };
            }

            console.log("Sending payload:", payload);

            const response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                 const errorData = await response.json();
                 throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            updateUI(data); // Обновляем UI новым состоянием от сервера

        } catch (error) {
            console.error('Error confirming move:', error);
            messageArea.textContent = `Ошибка хода: ${error.message}`;
            // Восстанавливаем кнопки, если произошла ошибка
            confirmButton.disabled = currentGameState?.currentPlayer !== humanPlayerIndex || currentGameState?.isGameOver;
             discardButton.disabled = currentGameState?.currentPlayer !== humanPlayerIndex || currentGameState?.isGameOver || currentGameState?.street === 1 || (currentGameState?.isFantasylandRound && currentGameState?.playerFantasylandStatus);

        } finally {
             // Сбрасываем выбор и временные данные хода в любом случае
             selectedCardsForPlacement = [];
             selectedCardToDiscard = null;
             placedCardsThisTurn = [];
             discardModeActive = false;
             discardButton.textContent = "Сбросить";
             // Обновляем UI кнопок на основе полученного состояния (если оно пришло)
             if (currentGameState) updateSelectionUI();
        }
    }


    // --- Инициализация при загрузке ---
    document.addEventListener('DOMContentLoaded', () => {
        // Пытаемся загрузить состояние с сервера при первой загрузке
        // Это полезно, если страница была обновлена
        fetch('/') // Просто делаем GET запрос на главную страницу
            .then(response => response.text())
            .then(html => {
                 // Пытаемся извлечь game_state из ответа (если он там есть)
                 // Это хрупкий способ, лучше иметь отдельный /get_state эндпоинт
                 const match = html.match(/let gameState = (\{.*?\});/);
                 if (match && match[1]) {
                      try {
                           const initialState = JSON.parse(match[1]);
                           updateUI(initialState);
                      } catch(e) {
                           console.error("Failed to parse initial state from HTML", e);
                           // Если не удалось, просто показываем кнопку "Начать"
                           setupEmptyBoards();
                           messageArea.textContent = "Нажмите 'Начать Раунд'";
                           document.getElementById('start-button').disabled = false;
                      }
                 } else {
                      setupEmptyBoards();
                      messageArea.textContent = "Нажмите 'Начать Раунд'";
                      document.getElementById('start-button').disabled = false;
                 }
            })
            .catch(error => {
                 console.error("Error fetching initial state:", error);
                 setupEmptyBoards();
                 messageArea.textContent = "Ошибка загрузки. Нажмите 'Начать Раунд'";
                 document.getElementById('start-button').disabled = false;
            });
    });

    function setupEmptyBoards() {
         renderBoard('player', { top: Array(3).fill(null), middle: Array(5).fill(null), bottom: Array(5).fill(null) });
         renderBoard('ai', { top: Array(3).fill(null), middle: Array(5).fill(null), bottom: Array(5).fill(null) });
         handElement.innerHTML = '';
         document.getElementById('discard-pile').textContent = "Сброс: -";
    }

</script>
</body>
</html>
